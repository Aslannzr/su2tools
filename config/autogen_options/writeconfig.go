package main

import (
	"errors"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
)

var autogenmessage = `// This file was autogenerated by github.com/btracey/su2tools/config/autogen_options/

`
var packageHeader = `package config

`

func writeConfigAndDefault(categories []*ConfigCategory, options []*ConfigOption) {

	optionStructFilename := filepath.Join(configPath, "option_struct.go")
	defaultStructFilename := filepath.Join(configPath, "default_struct.go")
	newOptionsFilename := filepath.Join(configPath, "new_struct.go")

	optionFile, err := os.Create(optionStructFilename)
	if err != nil {
		log.Fatalf("error creating %s: %v", optionStructFilename, err)
	}

	defaultFile, err := os.Create(defaultStructFilename)
	if err != nil {
		log.Fatalf("error creating %s: %v", defaultStructFilename, err)
	}

	newOptionsFile, err := os.Create(newOptionsFilename)
	if err != nil {
		log.Fatalf("error creating %s: %v", defaultStructFilename, err)
	}

	optionFile.WriteString(packageHeader)
	optionFile.WriteString(autogenmessage)

	defaultFile.WriteString(packageHeader)
	defaultFile.WriteString(autogenmessage)

	newOptionsFile.WriteString(packageHeader)
	newOptionsFile.WriteString(autogenmessage)

	imports := "import (\n"
	imports += "\"" + configImportPath + "/enum\"\n"
	imports += "\"" + configImportPath + "/su2types\"\n"
	imports += ")\n\n"

	optionFile.WriteString(imports)

	//imp := "import \"" + configImportPath + "/enum\"\n"
	defaultFile.WriteString(imports)

	newOptionsFile.WriteString(imports)

	optionFile.WriteString("type Options struct {\n")
	defaultFile.WriteString("var defaultOptions = &Options{\n")

	newOptionsFile.WriteString("func NewOptions() *Options{\nreturn &Options{\n")

	//optionList := alphabeticalOptionList(options)
	optionList := options

	for _, option := range optionList {
		optionFile.WriteString("// " + option.Description + "\n")
		optionFile.WriteString(option.Value + " ")
		gotype, err := goTypeFromConfigType(option.Type, option.ExtraType)
		if err != nil {
			log.Fatal(err.Error())
		}
		optionFile.WriteString(gotype + "\n")

		defStr := option.Value + ": "

		if option.Type == "Enum" {
			defStr += "enum." + option.Default + ",\n"
		} else if option.Default == "NONE" {
			defStr += "nil,\n"
		} else {
			defStr += option.Default + ",\n"
		}
		defaultFile.WriteString(defStr)
		newOptionsFile.WriteString(defStr)
	}

	optionFile.WriteString("}\n")
	defaultFile.WriteString("}\n")
	newOptionsFile.WriteString("}\n}\n")

	optionFile.Close()
	defaultFile.Close()

	b, err := ioutil.ReadFile(optionStructFilename)
	if err != nil {
		log.Fatalf("error creating %s: %v", optionStructFilename, err)
	}
	b, err = format.Source(b)
	if err != nil {
		log.Fatalf("error formatting %s: %v", optionStructFilename, err)
	}
	err = ioutil.WriteFile(optionStructFilename, b, 0700)
	if err != nil {
		log.Fatalf("error writing %s: %v", optionStructFilename, err)
	}

	b, err = ioutil.ReadFile(defaultStructFilename)
	if err != nil {
		log.Fatalf("error creating %s: %v", defaultStructFilename, err)
	}
	b, err = format.Source(b)
	if err != nil {
		log.Fatalf("error formatting %s: %v", defaultStructFilename, err)
	}
	err = ioutil.WriteFile(defaultStructFilename, b, 0700)
	if err != nil {
		log.Fatalf("error writing %s: %v", defaultStructFilename, err)
	}

	b, err = ioutil.ReadFile(newOptionsFilename)
	if err != nil {
		log.Fatalf("error creating %s: %v", newOptionsFilename, err)
	}
	b, err = format.Source(b)
	if err != nil {
		log.Fatalf("error formatting %s: %v", newOptionsFilename, err)
	}
	err = ioutil.WriteFile(newOptionsFilename, b, 0700)
	if err != nil {
		log.Fatalf("error writing %s: %v", newOptionsFilename, err)
	}
}

func goTypeFromConfigType(typename, extra string) (string, error) {
	switch typename {
	default:
		return "", errors.New("unknown typename " + typename)
	case "Double":
		return "float64", nil
	case "String":
		return "string", nil
	case "Integer":
		return "int32", nil
	case "UnsignedLong":
		return "uint64", nil
	case "UnsignedShort":
		return "uint16", nil
	case "Long":
		return "int", nil
	case "Bool":
		return "bool", nil
	case "StringList":
		return "[]string", nil
	case "DoubleArray":
		return "[" + extra + "]float64", nil
	case "Enum":
		return "enum." + extra, nil
	case "Convect":
		return "string", nil // This has to be a string because convect is really two different enum types
	case "EnumList":
		return "[]enum." + extra, nil
	case "DVParam":
		return "*su2types.DVParam", nil
	case "DoubleList":
		return "[]float64", nil
	case "UShortList":
		return "[]uint16", nil
	case "StringDoubleList":
		return "*su2types.StringDoubleList", nil
	case "Inlet":
		return "*su2types.Inlet", nil
	case "InletFixed":
		return "*su2types.InletFixed", nil
	case "ActuatorDisk":
		return "*su2types.ActuatorDisk", nil
	case "Periodic":
		return "*su2types.Periodic", nil
	case "MathProblem":
		return "enum.MathProblem", nil
	case "Python":
		return "*su2types.Python", nil
	}
}

type configOptionList []*ConfigOption

func (c configOptionList) Len() int {
	return len(c)
}

func (c configOptionList) Swap(i, j int) {
	c[i], c[j] = c[j], c[i]
}

func (c configOptionList) Less(i, j int) bool {
	return c[i].Value < c[j].Value
}

/*
func alphabeticalOptionList(options map[string]*ConfigOption) configOptionList {
	list := make(configOptionList, len(options))
	var i int
	for _, val := range options {
		list[i] = val
		i++
	}
	sort.Sort(list)
	return list
}
*/
