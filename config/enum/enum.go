// package enum contains a type-safe version of all of the enum types
// that are accessible from the SU2 config file.

package enum

// This file is autogenerated by github.com/btracey/su2tools/config/enum/autogen/genenum

import "errors"

var Unknown = errors.New("unknown enum string")

type Adapt uint16

func (e Adapt) String() string {
	return mapAdapt[e]
}

func (e Adapt) ConfigString() string {
	return mapAdaptToConfig[e]
}

func (e *Adapt) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Adapt")
	}
	enum, ok := mapAdaptFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Computable Adapt = iota
	ComputableRobust
	Full
	FullAdjoint
	FullFlow
	FullLinear
	GradAdjoint
	GradFlow
	GradFlowAdj
	NoAdapt
	Remaining
	Robust
	Smoothing
	SupersonicShock
	Twophase
	Wake
)

var mapAdapt = map[Adapt]string{
	Computable:       "Computable",
	ComputableRobust: "ComputableRobust",
	Full:             "Full",
	FullAdjoint:      "FullAdjoint",
	FullFlow:         "FullFlow",
	FullLinear:       "FullLinear",
	GradAdjoint:      "GradAdjoint",
	GradFlow:         "GradFlow",
	GradFlowAdj:      "GradFlowAdj",
	NoAdapt:          "NoAdapt",
	Remaining:        "Remaining",
	Robust:           "Robust",
	Smoothing:        "Smoothing",
	SupersonicShock:  "SupersonicShock",
	Twophase:         "Twophase",
	Wake:             "Wake",
}

var mapAdaptToConfig = map[Adapt]string{
	Computable:       "COMPUTABLE",
	ComputableRobust: "COMPUTABLE_ROBUST",
	Full:             "FULL",
	FullAdjoint:      "FULL_ADJOINT",
	FullFlow:         "FULL_FLOW",
	FullLinear:       "FULL_LINEAR",
	GradAdjoint:      "GRAD_ADJOINT",
	GradFlow:         "GRAD_FLOW",
	GradFlowAdj:      "GRAD_FLOW_ADJ",
	NoAdapt:          "NONE",
	Remaining:        "REMAINING",
	Robust:           "ROBUST",
	Smoothing:        "SMOOTHING",
	SupersonicShock:  "SUPERSONIC_SHOCK",
	Twophase:         "TWOPHASE",
	Wake:             "WAKE",
}

var mapAdaptFromConfig = map[string]Adapt{
	"COMPUTABLE":        Computable,
	"COMPUTABLE_ROBUST": ComputableRobust,
	"FULL":              Full,
	"FULL_ADJOINT":      FullAdjoint,
	"FULL_FLOW":         FullFlow,
	"FULL_LINEAR":       FullLinear,
	"GRAD_ADJOINT":      GradAdjoint,
	"GRAD_FLOW":         GradFlow,
	"GRAD_FLOW_ADJ":     GradFlowAdj,
	"NONE":              NoAdapt,
	"REMAINING":         Remaining,
	"ROBUST":            Robust,
	"SMOOTHING":         Smoothing,
	"SUPERSONIC_SHOCK":  SupersonicShock,
	"TWOPHASE":          Twophase,
	"WAKE":              Wake,
}

type AxisOrientation uint16

func (e AxisOrientation) String() string {
	return mapAxisOrientation[e]
}

func (e AxisOrientation) ConfigString() string {
	return mapAxisOrientationToConfig[e]
}

func (e *AxisOrientation) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field AxisOrientation")
	}
	enum, ok := mapAxisOrientationFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	XAxis AxisOrientation = iota
	YAxis
	ZAxis
)

var mapAxisOrientation = map[AxisOrientation]string{
	XAxis: "XAxis",
	YAxis: "YAxis",
	ZAxis: "ZAxis",
}

var mapAxisOrientationToConfig = map[AxisOrientation]string{
	XAxis: "X_AXIS",
	YAxis: "Y_AXIS",
	ZAxis: "Z_AXIS",
}

var mapAxisOrientationFromConfig = map[string]AxisOrientation{
	"X_AXIS": XAxis,
	"Y_AXIS": YAxis,
	"Z_AXIS": ZAxis,
}

type Centered uint16

func (e Centered) String() string {
	return mapCentered[e]
}

func (e Centered) ConfigString() string {
	return mapCenteredToConfig[e]
}

func (e *Centered) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Centered")
	}
	enum, ok := mapCenteredFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Jst Centered = iota
	JstKe
	Lax
	NoCentered
)

var mapCentered = map[Centered]string{
	Jst:        "Jst",
	JstKe:      "JstKe",
	Lax:        "Lax",
	NoCentered: "NoCentered",
}

var mapCenteredToConfig = map[Centered]string{
	Jst:        "JST",
	JstKe:      "JST_KE",
	Lax:        "LAX-FRIEDRICH",
	NoCentered: "NONE",
}

var mapCenteredFromConfig = map[string]Centered{
	"JST":           Jst,
	"JST_KE":        JstKe,
	"LAX-FRIEDRICH": Lax,
	"NONE":          NoCentered,
}

type ContinuousEqns uint16

func (e ContinuousEqns) String() string {
	return mapContinuousEqns[e]
}

func (e ContinuousEqns) ConfigString() string {
	return mapContinuousEqnsToConfig[e]
}

func (e *ContinuousEqns) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field ContinuousEqns")
	}
	enum, ok := mapContinuousEqnsFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	EulerEqns ContinuousEqns = iota
	NavierStokesEqns
)

var mapContinuousEqns = map[ContinuousEqns]string{
	EulerEqns:        "EulerEqns",
	NavierStokesEqns: "NavierStokesEqns",
}

var mapContinuousEqnsToConfig = map[ContinuousEqns]string{
	EulerEqns:        "EULER",
	NavierStokesEqns: "NAVIER_STOKES",
}

var mapContinuousEqnsFromConfig = map[string]ContinuousEqns{
	"EULER":         EulerEqns,
	"NAVIER_STOKES": NavierStokesEqns,
}

type ConvergeCrit uint16

func (e ConvergeCrit) String() string {
	return mapConvergeCrit[e]
}

func (e ConvergeCrit) ConfigString() string {
	return mapConvergeCritToConfig[e]
}

func (e *ConvergeCrit) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field ConvergeCrit")
	}
	enum, ok := mapConvergeCritFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Cauchy ConvergeCrit = iota
	Residual
)

var mapConvergeCrit = map[ConvergeCrit]string{
	Cauchy:   "Cauchy",
	Residual: "Residual",
}

var mapConvergeCritToConfig = map[ConvergeCrit]string{
	Cauchy:   "CAUCHY",
	Residual: "RESIDUAL",
}

var mapConvergeCritFromConfig = map[string]ConvergeCrit{
	"CAUCHY":   Cauchy,
	"RESIDUAL": Residual,
}

type DeformStiffness uint16

func (e DeformStiffness) String() string {
	return mapDeformStiffness[e]
}

func (e DeformStiffness) ConfigString() string {
	return mapDeformStiffnessToConfig[e]
}

func (e *DeformStiffness) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field DeformStiffness")
	}
	enum, ok := mapDeformStiffnessFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	ConstantStiffness DeformStiffness = iota
	InverseVolume
	WallDistance
)

var mapDeformStiffness = map[DeformStiffness]string{
	ConstantStiffness: "ConstantStiffness",
	InverseVolume:     "InverseVolume",
	WallDistance:      "WallDistance",
}

var mapDeformStiffnessToConfig = map[DeformStiffness]string{
	ConstantStiffness: "CONSTANT_STIFFNESS",
	InverseVolume:     "INVERSE_VOLUME",
	WallDistance:      "WALL_DISTANCE",
}

var mapDeformStiffnessFromConfig = map[string]DeformStiffness{
	"CONSTANT_STIFFNESS": ConstantStiffness,
	"INVERSE_VOLUME":     InverseVolume,
	"WALL_DISTANCE":      WallDistance,
}

type DiscreteEqns uint16

func (e DiscreteEqns) String() string {
	return mapDiscreteEqns[e]
}

func (e DiscreteEqns) ConfigString() string {
	return mapDiscreteEqnsToConfig[e]
}

func (e *DiscreteEqns) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field DiscreteEqns")
	}
	enum, ok := mapDiscreteEqnsFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	NoneEqns DiscreteEqns = iota
	SaEqns
	SstEqns
)

var mapDiscreteEqns = map[DiscreteEqns]string{
	NoneEqns: "NoneEqns",
	SaEqns:   "SaEqns",
	SstEqns:  "SstEqns",
}

var mapDiscreteEqnsToConfig = map[DiscreteEqns]string{
	NoneEqns: "NONE",
	SaEqns:   "SA",
	SstEqns:  "SST",
}

var mapDiscreteEqnsFromConfig = map[string]DiscreteEqns{
	"NONE": NoneEqns,
	"SA":   SaEqns,
	"SST":  SstEqns,
}

type FlowGradient uint16

func (e FlowGradient) String() string {
	return mapFlowGradient[e]
}

func (e FlowGradient) ConfigString() string {
	return mapFlowGradientToConfig[e]
}

func (e *FlowGradient) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field FlowGradient")
	}
	enum, ok := mapFlowGradientFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	GreenGauss FlowGradient = iota
	WeightedLeastSquares
)

var mapFlowGradient = map[FlowGradient]string{
	GreenGauss:           "GreenGauss",
	WeightedLeastSquares: "WeightedLeastSquares",
}

var mapFlowGradientToConfig = map[FlowGradient]string{
	GreenGauss:           "GREEN_GAUSS",
	WeightedLeastSquares: "WEIGHTED_LEAST_SQUARES",
}

var mapFlowGradientFromConfig = map[string]FlowGradient{
	"GREEN_GAUSS":            GreenGauss,
	"WEIGHTED_LEAST_SQUARES": WeightedLeastSquares,
}

type Gasmodel uint16

func (e Gasmodel) String() string {
	return mapGasmodel[e]
}

func (e Gasmodel) ConfigString() string {
	return mapGasmodelToConfig[e]
}

func (e *Gasmodel) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Gasmodel")
	}
	enum, ok := mapGasmodelFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Air21 Gasmodel = iota
	Air5
	Air7
	Argon
	ArgonSid
	N2
	NoModel
	O2
	Onespecies
)

var mapGasmodel = map[Gasmodel]string{
	Air21:      "Air21",
	Air5:       "Air5",
	Air7:       "Air7",
	Argon:      "Argon",
	ArgonSid:   "ArgonSid",
	N2:         "N2",
	NoModel:    "NoModel",
	O2:         "O2",
	Onespecies: "Onespecies",
}

var mapGasmodelToConfig = map[Gasmodel]string{
	Air21:      "AIR-21",
	Air5:       "AIR-5",
	Air7:       "AIR-7",
	Argon:      "ARGON",
	ArgonSid:   "ARGON-SID",
	N2:         "N2",
	NoModel:    "NONE",
	O2:         "O2",
	Onespecies: "ONESPECIES",
}

var mapGasmodelFromConfig = map[string]Gasmodel{
	"AIR-21":     Air21,
	"AIR-5":      Air5,
	"AIR-7":      Air7,
	"ARGON":      Argon,
	"ARGON-SID":  ArgonSid,
	"N2":         N2,
	"NONE":       NoModel,
	"O2":         O2,
	"ONESPECIES": Onespecies,
}

type GeoAnalytic uint16

func (e GeoAnalytic) String() string {
	return mapGeoAnalytic[e]
}

func (e GeoAnalytic) ConfigString() string {
	return mapGeoAnalyticToConfig[e]
}

func (e *GeoAnalytic) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field GeoAnalytic")
	}
	enum, ok := mapGeoAnalyticFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Biparabolic GeoAnalytic = iota
	Cylinder
	Naca0012Airfoil
	Naca4412Airfoil
	NoGeoAnalytic
)

var mapGeoAnalytic = map[GeoAnalytic]string{
	Biparabolic:     "Biparabolic",
	Cylinder:        "Cylinder",
	Naca0012Airfoil: "Naca0012Airfoil",
	Naca4412Airfoil: "Naca4412Airfoil",
	NoGeoAnalytic:   "NoGeoAnalytic",
}

var mapGeoAnalyticToConfig = map[GeoAnalytic]string{
	Biparabolic:     "BIPARABOLIC",
	Cylinder:        "CYLINDER",
	Naca0012Airfoil: "NACA0012_AIRFOIL",
	Naca4412Airfoil: "NACA4412_AIRFOIL",
	NoGeoAnalytic:   "NONE",
}

var mapGeoAnalyticFromConfig = map[string]GeoAnalytic{
	"BIPARABOLIC":      Biparabolic,
	"CYLINDER":         Cylinder,
	"NACA0012_AIRFOIL": Naca0012Airfoil,
	"NACA4412_AIRFOIL": Naca4412Airfoil,
	"NONE":             NoGeoAnalytic,
}

type GeometryMode uint16

func (e GeometryMode) String() string {
	return mapGeometryMode[e]
}

func (e GeometryMode) ConfigString() string {
	return mapGeometryModeToConfig[e]
}

func (e *GeometryMode) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field GeometryMode")
	}
	enum, ok := mapGeometryModeFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Function GeometryMode = iota
	Gradient
)

var mapGeometryMode = map[GeometryMode]string{
	Function: "Function",
	Gradient: "Gradient",
}

var mapGeometryModeToConfig = map[GeometryMode]string{
	Function: "FUNCTION",
	Gradient: "GRADIENT",
}

var mapGeometryModeFromConfig = map[string]GeometryMode{
	"FUNCTION": Function,
	"GRADIENT": Gradient,
}

type Gridmovement uint16

func (e Gridmovement) String() string {
	return mapGridmovement[e]
}

func (e Gridmovement) ConfigString() string {
	return mapGridmovementToConfig[e]
}

func (e *Gridmovement) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Gridmovement")
	}
	enum, ok := mapGridmovementFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Aeroelastic Gridmovement = iota
	AeroelasticRigidMotion
	Deforming
	Elasticity
	External
	ExternalRotation
	FluidStructure
	MovingWall
	NoMovement
	RigidMotion
	RotatingFrame
)

var mapGridmovement = map[Gridmovement]string{
	Aeroelastic:            "Aeroelastic",
	AeroelasticRigidMotion: "AeroelasticRigidMotion",
	Deforming:              "Deforming",
	Elasticity:             "Elasticity",
	External:               "External",
	ExternalRotation:       "ExternalRotation",
	FluidStructure:         "FluidStructure",
	MovingWall:             "MovingWall",
	NoMovement:             "NoMovement",
	RigidMotion:            "RigidMotion",
	RotatingFrame:          "RotatingFrame",
}

var mapGridmovementToConfig = map[Gridmovement]string{
	Aeroelastic:            "AEROELASTIC",
	AeroelasticRigidMotion: "AEROELASTIC_RIGID_MOTION",
	Deforming:              "DEFORMING",
	Elasticity:             "ELASTICITY",
	External:               "EXTERNAL",
	ExternalRotation:       "EXTERNAL_ROTATION",
	FluidStructure:         "FLUID_STRUCTURE",
	MovingWall:             "MOVING_WALL",
	NoMovement:             "NONE",
	RigidMotion:            "RIGID_MOTION",
	RotatingFrame:          "ROTATING_FRAME",
}

var mapGridmovementFromConfig = map[string]Gridmovement{
	"AEROELASTIC":              Aeroelastic,
	"AEROELASTIC_RIGID_MOTION": AeroelasticRigidMotion,
	"DEFORMING":                Deforming,
	"ELASTICITY":               Elasticity,
	"EXTERNAL":                 External,
	"EXTERNAL_ROTATION":        ExternalRotation,
	"FLUID_STRUCTURE":          FluidStructure,
	"MOVING_WALL":              MovingWall,
	"NONE":                     NoMovement,
	"RIGID_MOTION":             RigidMotion,
	"ROTATING_FRAME":           RotatingFrame,
}

type GustDir uint16

func (e GustDir) String() string {
	return mapGustDir[e]
}

func (e GustDir) ConfigString() string {
	return mapGustDirToConfig[e]
}

func (e *GustDir) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field GustDir")
	}
	enum, ok := mapGustDirFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	XDir GustDir = iota
	YDir
)

var mapGustDir = map[GustDir]string{
	XDir: "XDir",
	YDir: "YDir",
}

var mapGustDirToConfig = map[GustDir]string{
	XDir: "X_DIR",
	YDir: "Y_DIR",
}

var mapGustDirFromConfig = map[string]GustDir{
	"X_DIR": XDir,
	"Y_DIR": YDir,
}

type GustType uint16

func (e GustType) String() string {
	return mapGustType[e]
}

func (e GustType) ConfigString() string {
	return mapGustTypeToConfig[e]
}

func (e *GustType) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field GustType")
	}
	enum, ok := mapGustTypeFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Eog GustType = iota
	NoGust
	OneMCosine
	Sine
	TopHat
	Vortex
)

var mapGustType = map[GustType]string{
	Eog:        "Eog",
	NoGust:     "NoGust",
	OneMCosine: "OneMCosine",
	Sine:       "Sine",
	TopHat:     "TopHat",
	Vortex:     "Vortex",
}

var mapGustTypeToConfig = map[GustType]string{
	Eog:        "EOG",
	NoGust:     "NONE",
	OneMCosine: "ONE_M_COSINE",
	Sine:       "SINE",
	TopHat:     "TOP_HAT",
	Vortex:     "VORTEX",
}

var mapGustTypeFromConfig = map[string]GustType{
	"EOG":          Eog,
	"NONE":         NoGust,
	"ONE_M_COSINE": OneMCosine,
	"SINE":         Sine,
	"TOP_HAT":      TopHat,
	"VORTEX":       Vortex,
}

type InletType uint16

func (e InletType) String() string {
	return mapInletType[e]
}

func (e InletType) ConfigString() string {
	return mapInletTypeToConfig[e]
}

func (e *InletType) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field InletType")
	}
	enum, ok := mapInletTypeFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	MassFlow InletType = iota
	TotalConditions
)

var mapInletType = map[InletType]string{
	MassFlow:        "MassFlow",
	TotalConditions: "TotalConditions",
}

var mapInletTypeToConfig = map[InletType]string{
	MassFlow:        "MASS_FLOW",
	TotalConditions: "TOTAL_CONDITIONS",
}

var mapInletTypeFromConfig = map[string]InletType{
	"MASS_FLOW":        MassFlow,
	"TOTAL_CONDITIONS": TotalConditions,
}

type Input uint16

func (e Input) String() string {
	return mapInput[e]
}

func (e Input) ConfigString() string {
	return mapInputToConfig[e]
}

func (e *Input) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Input")
	}
	enum, ok := mapInputFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Cgns Input = iota
	NetcdfAscii
	Su2
)

var mapInput = map[Input]string{
	Cgns:        "Cgns",
	NetcdfAscii: "NetcdfAscii",
	Su2:         "Su2",
}

var mapInputToConfig = map[Input]string{
	Cgns:        "CGNS",
	NetcdfAscii: "NETCDF_ASCII",
	Su2:         "SU2",
}

var mapInputFromConfig = map[string]Input{
	"CGNS":         Cgns,
	"NETCDF_ASCII": NetcdfAscii,
	"SU2":          Su2,
}

type Limiter uint16

func (e Limiter) String() string {
	return mapLimiter[e]
}

func (e Limiter) ConfigString() string {
	return mapLimiterToConfig[e]
}

func (e *Limiter) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Limiter")
	}
	enum, ok := mapLimiterFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Minmod Limiter = iota
	SharpEdges
	Venkatakrishnan
)

var mapLimiter = map[Limiter]string{
	Minmod:          "Minmod",
	SharpEdges:      "SharpEdges",
	Venkatakrishnan: "Venkatakrishnan",
}

var mapLimiterToConfig = map[Limiter]string{
	Minmod:          "MINMOD",
	SharpEdges:      "SHARP_EDGES",
	Venkatakrishnan: "VENKATAKRISHNAN",
}

var mapLimiterFromConfig = map[string]Limiter{
	"MINMOD":          Minmod,
	"SHARP_EDGES":     SharpEdges,
	"VENKATAKRISHNAN": Venkatakrishnan,
}

type LinearObj uint16

func (e LinearObj) String() string {
	return mapLinearObj[e]
}

func (e LinearObj) ConfigString() string {
	return mapLinearObjToConfig[e]
}

func (e *LinearObj) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field LinearObj")
	}
	enum, ok := mapLinearObjFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	DeltaDragCoefficient LinearObj = iota
	DeltaLiftCoefficient
)

var mapLinearObj = map[LinearObj]string{
	DeltaDragCoefficient: "DeltaDragCoefficient",
	DeltaLiftCoefficient: "DeltaLiftCoefficient",
}

var mapLinearObjToConfig = map[LinearObj]string{
	DeltaDragCoefficient: "DELTA_DRAG",
	DeltaLiftCoefficient: "DELTA_LIFT",
}

var mapLinearObjFromConfig = map[string]LinearObj{
	"DELTA_DRAG": DeltaDragCoefficient,
	"DELTA_LIFT": DeltaLiftCoefficient,
}

type LinearSolver uint16

func (e LinearSolver) String() string {
	return mapLinearSolver[e]
}

func (e LinearSolver) ConfigString() string {
	return mapLinearSolverToConfig[e]
}

func (e *LinearSolver) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field LinearSolver")
	}
	enum, ok := mapLinearSolverFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Bcgstab LinearSolver = iota
	ConjugateGradient
	Fgmres
	Newton
	QuasiNewton
	Rfgmres
	SteepestDescent
)

var mapLinearSolver = map[LinearSolver]string{
	Bcgstab:           "Bcgstab",
	ConjugateGradient: "ConjugateGradient",
	Fgmres:            "Fgmres",
	Newton:            "Newton",
	QuasiNewton:       "QuasiNewton",
	Rfgmres:           "Rfgmres",
	SteepestDescent:   "SteepestDescent",
}

var mapLinearSolverToConfig = map[LinearSolver]string{
	Bcgstab:           "BCGSTAB",
	ConjugateGradient: "CONJUGATE_GRADIENT",
	Fgmres:            "FGMRES",
	Newton:            "NEWTON",
	QuasiNewton:       "QUASI_NEWTON",
	Rfgmres:           "RFGMRES",
	SteepestDescent:   "STEEPEST_DESCENT",
}

var mapLinearSolverFromConfig = map[string]LinearSolver{
	"BCGSTAB":            Bcgstab,
	"CONJUGATE_GRADIENT": ConjugateGradient,
	"FGMRES":             Fgmres,
	"NEWTON":             Newton,
	"QUASI_NEWTON":       QuasiNewton,
	"RFGMRES":            Rfgmres,
	"STEEPEST_DESCENT":   SteepestDescent,
}

type LinearSolverPrec uint16

func (e LinearSolverPrec) String() string {
	return mapLinearSolverPrec[e]
}

func (e LinearSolverPrec) ConfigString() string {
	return mapLinearSolverPrecToConfig[e]
}

func (e *LinearSolverPrec) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field LinearSolverPrec")
	}
	enum, ok := mapLinearSolverPrecFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Jacobi LinearSolverPrec = iota
	Linelet
	LuSgs
)

var mapLinearSolverPrec = map[LinearSolverPrec]string{
	Jacobi:  "Jacobi",
	Linelet: "Linelet",
	LuSgs:   "LuSgs",
}

var mapLinearSolverPrecToConfig = map[LinearSolverPrec]string{
	Jacobi:  "JACOBI",
	Linelet: "LINELET",
	LuSgs:   "LU_SGS",
}

var mapLinearSolverPrecFromConfig = map[string]LinearSolverPrec{
	"JACOBI":  Jacobi,
	"LINELET": Linelet,
	"LU_SGS":  LuSgs,
}

type MathProblem uint16

func (e MathProblem) String() string {
	return mapMathProblem[e]
}

func (e MathProblem) ConfigString() string {
	return mapMathProblemToConfig[e]
}

func (e *MathProblem) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field MathProblem")
	}
	enum, ok := mapMathProblemFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	AdjointProblem MathProblem = iota
	DirectProblem
	LinearizedProblem
)

var mapMathProblem = map[MathProblem]string{
	AdjointProblem:    "AdjointProblem",
	DirectProblem:     "DirectProblem",
	LinearizedProblem: "LinearizedProblem",
}

var mapMathProblemToConfig = map[MathProblem]string{
	AdjointProblem:    "ADJOINT",
	DirectProblem:     "DIRECT",
	LinearizedProblem: "LINEARIZED",
}

var mapMathProblemFromConfig = map[string]MathProblem{
	"ADJOINT":    AdjointProblem,
	"DIRECT":     DirectProblem,
	"LINEARIZED": LinearizedProblem,
}

type Objective uint16

func (e Objective) String() string {
	return mapObjective[e]
}

func (e Objective) ConfigString() string {
	return mapObjectiveToConfig[e]
}

func (e *Objective) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Objective")
	}
	enum, ok := mapObjectiveFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	DragCoefficient Objective = iota
	Efficiency
	EquivalentArea
	FigureOfMerit
	ForceXCoefficient
	ForceYCoefficient
	ForceZCoefficient
	FreeSurface
	InverseDesignHeatflux
	InverseDesignPressure
	LiftCoefficient
	MaxThickSec1
	MaxThickSec2
	MaxThickSec3
	MaxThickSec4
	MaxThickSec5
	MaxThickness
	MaximumHeatflux
	MinThickness
	MomentXCoefficient
	MomentYCoefficient
	MomentZCoefficient
	NearfieldPressure
	SideforceCoefficient
	ThrustCoefficient
	TorqueCoefficient
	TotalHeatflux
)

var mapObjective = map[Objective]string{
	DragCoefficient:       "DragCoefficient",
	Efficiency:            "Efficiency",
	EquivalentArea:        "EquivalentArea",
	FigureOfMerit:         "FigureOfMerit",
	ForceXCoefficient:     "ForceXCoefficient",
	ForceYCoefficient:     "ForceYCoefficient",
	ForceZCoefficient:     "ForceZCoefficient",
	FreeSurface:           "FreeSurface",
	InverseDesignHeatflux: "InverseDesignHeatflux",
	InverseDesignPressure: "InverseDesignPressure",
	LiftCoefficient:       "LiftCoefficient",
	MaxThickSec1:          "MaxThickSec1",
	MaxThickSec2:          "MaxThickSec2",
	MaxThickSec3:          "MaxThickSec3",
	MaxThickSec4:          "MaxThickSec4",
	MaxThickSec5:          "MaxThickSec5",
	MaxThickness:          "MaxThickness",
	MaximumHeatflux:       "MaximumHeatflux",
	MinThickness:          "MinThickness",
	MomentXCoefficient:    "MomentXCoefficient",
	MomentYCoefficient:    "MomentYCoefficient",
	MomentZCoefficient:    "MomentZCoefficient",
	NearfieldPressure:     "NearfieldPressure",
	SideforceCoefficient:  "SideforceCoefficient",
	ThrustCoefficient:     "ThrustCoefficient",
	TorqueCoefficient:     "TorqueCoefficient",
	TotalHeatflux:         "TotalHeatflux",
}

var mapObjectiveToConfig = map[Objective]string{
	DragCoefficient:       "DRAG",
	Efficiency:            "EFFICIENCY",
	EquivalentArea:        "EQUIVALENT_AREA",
	FigureOfMerit:         "FIGURE_OF_MERIT",
	ForceXCoefficient:     "FORCE_X",
	ForceYCoefficient:     "FORCE_Y",
	ForceZCoefficient:     "FORCE_Z",
	FreeSurface:           "FREE_SURFACE",
	InverseDesignHeatflux: "INVERSE_DESIGN_HEATFLUX",
	InverseDesignPressure: "INVERSE_DESIGN_PRESSURE",
	LiftCoefficient:       "LIFT",
	MaxThickSec1:          "MAX_THICK_SEC1",
	MaxThickSec2:          "MAX_THICK_SEC2",
	MaxThickSec3:          "MAX_THICK_SEC3",
	MaxThickSec4:          "MAX_THICK_SEC4",
	MaxThickSec5:          "MAX_THICK_SEC5",
	MaxThickness:          "MAX_THICKNESS",
	MaximumHeatflux:       "MAXIMUM_HEATFLUX",
	MinThickness:          "MIN_THICKNESS",
	MomentXCoefficient:    "MOMENT_X",
	MomentYCoefficient:    "MOMENT_Y",
	MomentZCoefficient:    "MOMENT_Z",
	NearfieldPressure:     "NEARFIELD_PRESSURE",
	SideforceCoefficient:  "SIDEFORCE",
	ThrustCoefficient:     "THRUST",
	TorqueCoefficient:     "TORQUE",
	TotalHeatflux:         "TOTAL_HEATFLUX",
}

var mapObjectiveFromConfig = map[string]Objective{
	"DRAG":                    DragCoefficient,
	"EFFICIENCY":              Efficiency,
	"EQUIVALENT_AREA":         EquivalentArea,
	"FIGURE_OF_MERIT":         FigureOfMerit,
	"FORCE_X":                 ForceXCoefficient,
	"FORCE_Y":                 ForceYCoefficient,
	"FORCE_Z":                 ForceZCoefficient,
	"FREE_SURFACE":            FreeSurface,
	"INVERSE_DESIGN_HEATFLUX": InverseDesignHeatflux,
	"INVERSE_DESIGN_PRESSURE": InverseDesignPressure,
	"LIFT":               LiftCoefficient,
	"MAX_THICK_SEC1":     MaxThickSec1,
	"MAX_THICK_SEC2":     MaxThickSec2,
	"MAX_THICK_SEC3":     MaxThickSec3,
	"MAX_THICK_SEC4":     MaxThickSec4,
	"MAX_THICK_SEC5":     MaxThickSec5,
	"MAX_THICKNESS":      MaxThickness,
	"MAXIMUM_HEATFLUX":   MaximumHeatflux,
	"MIN_THICKNESS":      MinThickness,
	"MOMENT_X":           MomentXCoefficient,
	"MOMENT_Y":           MomentYCoefficient,
	"MOMENT_Z":           MomentZCoefficient,
	"NEARFIELD_PRESSURE": NearfieldPressure,
	"SIDEFORCE":          SideforceCoefficient,
	"THRUST":             ThrustCoefficient,
	"TORQUE":             TorqueCoefficient,
	"TOTAL_HEATFLUX":     TotalHeatflux,
}

type Output uint16

func (e Output) String() string {
	return mapOutput[e]
}

func (e Output) ConfigString() string {
	return mapOutputToConfig[e]
}

func (e *Output) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Output")
	}
	enum, ok := mapOutputFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	CgnsSol Output = iota
	Csv
	Excel
	Paraview
	Tecplot
	TecplotBinary
)

var mapOutput = map[Output]string{
	CgnsSol:       "CgnsSol",
	Csv:           "Csv",
	Excel:         "Excel",
	Paraview:      "Paraview",
	Tecplot:       "Tecplot",
	TecplotBinary: "TecplotBinary",
}

var mapOutputToConfig = map[Output]string{
	CgnsSol:       "CGNS",
	Csv:           "CSV",
	Excel:         "EXCEL",
	Paraview:      "PARAVIEW",
	Tecplot:       "TECPLOT",
	TecplotBinary: "TECPLOT_BINARY",
}

var mapOutputFromConfig = map[string]Output{
	"CGNS":           CgnsSol,
	"CSV":            Csv,
	"EXCEL":          Excel,
	"PARAVIEW":       Paraview,
	"TECPLOT":        Tecplot,
	"TECPLOT_BINARY": TecplotBinary,
}

type OutputVars uint16

func (e OutputVars) String() string {
	return mapOutputVars[e]
}

func (e OutputVars) ConfigString() string {
	return mapOutputVarsToConfig[e]
}

func (e *OutputVars) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field OutputVars")
	}
	enum, ok := mapOutputVarsFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Density OutputVars = iota
	EddyVisc
	LamVisc
	Mach
	Pressure
	Temperature
	VelX
	VelY
	VelZ
)

var mapOutputVars = map[OutputVars]string{
	Density:     "Density",
	EddyVisc:    "EddyVisc",
	LamVisc:     "LamVisc",
	Mach:        "Mach",
	Pressure:    "Pressure",
	Temperature: "Temperature",
	VelX:        "VelX",
	VelY:        "VelY",
	VelZ:        "VelZ",
}

var mapOutputVarsToConfig = map[OutputVars]string{
	Density:     "DENSITY",
	EddyVisc:    "EDDY_VISC",
	LamVisc:     "LAM_VISC",
	Mach:        "MACH",
	Pressure:    "PRESSURE",
	Temperature: "TEMPERATURE",
	VelX:        "VEL_X",
	VelY:        "VEL_Y",
	VelZ:        "VEL_Z",
}

var mapOutputVarsFromConfig = map[string]OutputVars{
	"DENSITY":     Density,
	"EDDY_VISC":   EddyVisc,
	"LAM_VISC":    LamVisc,
	"MACH":        Mach,
	"PRESSURE":    Pressure,
	"TEMPERATURE": Temperature,
	"VEL_X":       VelX,
	"VEL_Y":       VelY,
	"VEL_Z":       VelZ,
}

type Param uint16

func (e Param) String() string {
	return mapParam[e]
}

func (e Param) ConfigString() string {
	return mapParamToConfig[e]
}

func (e *Param) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Param")
	}
	enum, ok := mapParamFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Airfoil Param = iota
	CosineBump
	Displacement
	FfdCamber
	FfdCamber2d
	FfdControlPoint
	FfdControlPoint2d
	FfdDihedralAngle
	FfdRotation
	FfdSetting
	FfdThickness
	FfdThickness2d
	FfdTwistAngle
	Fourier
	HicksHenne
	Naca4digits
	Obstacle
	Parabolic
	Rotation
	Spherical
	Stretch
	SurfaceFile
)

var mapParam = map[Param]string{
	Airfoil:           "Airfoil",
	CosineBump:        "CosineBump",
	Displacement:      "Displacement",
	FfdCamber:         "FfdCamber",
	FfdCamber2d:       "FfdCamber2d",
	FfdControlPoint:   "FfdControlPoint",
	FfdControlPoint2d: "FfdControlPoint2d",
	FfdDihedralAngle:  "FfdDihedralAngle",
	FfdRotation:       "FfdRotation",
	FfdSetting:        "FfdSetting",
	FfdThickness:      "FfdThickness",
	FfdThickness2d:    "FfdThickness2d",
	FfdTwistAngle:     "FfdTwistAngle",
	Fourier:           "Fourier",
	HicksHenne:        "HicksHenne",
	Naca4digits:       "Naca4digits",
	Obstacle:          "Obstacle",
	Parabolic:         "Parabolic",
	Rotation:          "Rotation",
	Spherical:         "Spherical",
	Stretch:           "Stretch",
	SurfaceFile:       "SurfaceFile",
}

var mapParamToConfig = map[Param]string{
	Airfoil:           "AIRFOIL",
	CosineBump:        "COSINE_BUMP",
	Displacement:      "DISPLACEMENT",
	FfdCamber:         "FFD_CAMBER",
	FfdCamber2d:       "FFD_CAMBER_2D",
	FfdControlPoint:   "FFD_CONTROL_POINT",
	FfdControlPoint2d: "FFD_CONTROL_POINT_2D",
	FfdDihedralAngle:  "FFD_DIHEDRAL_ANGLE",
	FfdRotation:       "FFD_ROTATION",
	FfdSetting:        "FFD_SETTING",
	FfdThickness:      "FFD_THICKNESS",
	FfdThickness2d:    "FFD_THICKNESS_2D",
	FfdTwistAngle:     "FFD_TWIST_ANGLE",
	Fourier:           "FOURIER",
	HicksHenne:        "HICKS_HENNE",
	Naca4digits:       "NACA_4DIGITS",
	Obstacle:          "OBSTACLE",
	Parabolic:         "PARABOLIC",
	Rotation:          "ROTATION",
	Spherical:         "SPHERICAL",
	Stretch:           "STRETCH",
	SurfaceFile:       "SURFACE_FILE",
}

var mapParamFromConfig = map[string]Param{
	"AIRFOIL":              Airfoil,
	"COSINE_BUMP":          CosineBump,
	"DISPLACEMENT":         Displacement,
	"FFD_CAMBER":           FfdCamber,
	"FFD_CAMBER_2D":        FfdCamber2d,
	"FFD_CONTROL_POINT":    FfdControlPoint,
	"FFD_CONTROL_POINT_2D": FfdControlPoint2d,
	"FFD_DIHEDRAL_ANGLE":   FfdDihedralAngle,
	"FFD_ROTATION":         FfdRotation,
	"FFD_SETTING":          FfdSetting,
	"FFD_THICKNESS":        FfdThickness,
	"FFD_THICKNESS_2D":     FfdThickness2d,
	"FFD_TWIST_ANGLE":      FfdTwistAngle,
	"FOURIER":              Fourier,
	"HICKS_HENNE":          HicksHenne,
	"NACA_4DIGITS":         Naca4digits,
	"OBSTACLE":             Obstacle,
	"PARABOLIC":            Parabolic,
	"ROTATION":             Rotation,
	"SPHERICAL":            Spherical,
	"STRETCH":              Stretch,
	"SURFACE_FILE":         SurfaceFile,
}

type Regime uint16

func (e Regime) String() string {
	return mapRegime[e]
}

func (e Regime) ConfigString() string {
	return mapRegimeToConfig[e]
}

func (e *Regime) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Regime")
	}
	enum, ok := mapRegimeFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Compressible Regime = iota
	Freesurface
	Incompressible
)

var mapRegime = map[Regime]string{
	Compressible:   "Compressible",
	Freesurface:    "Freesurface",
	Incompressible: "Incompressible",
}

var mapRegimeToConfig = map[Regime]string{
	Compressible:   "COMPRESSIBLE",
	Freesurface:    "FREESURFACE",
	Incompressible: "INCOMPRESSIBLE",
}

var mapRegimeFromConfig = map[string]Regime{
	"COMPRESSIBLE":   Compressible,
	"FREESURFACE":    Freesurface,
	"INCOMPRESSIBLE": Incompressible,
}

type Sens uint16

func (e Sens) String() string {
	return mapSens[e]
}

func (e Sens) ConfigString() string {
	return mapSensToConfig[e]
}

func (e *Sens) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Sens")
	}
	enum, ok := mapSensFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	SensAoa Sens = iota
	SensAos
	SensGeometry
	SensMach
)

var mapSens = map[Sens]string{
	SensAoa:      "SensAoa",
	SensAos:      "SensAos",
	SensGeometry: "SensGeometry",
	SensMach:     "SensMach",
}

var mapSensToConfig = map[Sens]string{
	SensAoa:      "SENS_AOA",
	SensAos:      "SENS_AOS",
	SensGeometry: "SENS_GEOMETRY",
	SensMach:     "SENS_MACH",
}

var mapSensFromConfig = map[string]Sens{
	"SENS_AOA":      SensAoa,
	"SENS_AOS":      SensAos,
	"SENS_GEOMETRY": SensGeometry,
	"SENS_MACH":     SensMach,
}

type SensSmoothing uint16

func (e SensSmoothing) String() string {
	return mapSensSmoothing[e]
}

func (e SensSmoothing) ConfigString() string {
	return mapSensSmoothingToConfig[e]
}

func (e *SensSmoothing) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field SensSmoothing")
	}
	enum, ok := mapSensSmoothingFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Bigrid SensSmoothing = iota
	NoSmooth
	Sobolev
)

var mapSensSmoothing = map[SensSmoothing]string{
	Bigrid:   "Bigrid",
	NoSmooth: "NoSmooth",
	Sobolev:  "Sobolev",
}

var mapSensSmoothingToConfig = map[SensSmoothing]string{
	Bigrid:   "BIGRID",
	NoSmooth: "NONE",
	Sobolev:  "SOBOLEV",
}

var mapSensSmoothingFromConfig = map[string]SensSmoothing{
	"BIGRID":  Bigrid,
	"NONE":    NoSmooth,
	"SOBOLEV": Sobolev,
}

type Solver uint16

func (e Solver) String() string {
	return mapSolver[e]
}

func (e Solver) ConfigString() string {
	return mapSolverToConfig[e]
}

func (e *Solver) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Solver")
	}
	enum, ok := mapSolverFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	AdjEuler Solver = iota
	AdjNavierStokes
	AdjRans
	AdjTne2Euler
	AdjTne2NavierStokes
	Euler
	FluidStructureEuler
	FluidStructureNavierStokes
	FluidStructureRans
	HeatEquation
	LinEuler
	LinNavierStokes
	LinearElasticity
	NavierStokes
	NoSolver
	PoissonEquation
	Rans
	TemplateSolver
	Tne2Euler
	Tne2NavierStokes
	WaveEquation
)

var mapSolver = map[Solver]string{
	AdjEuler:                   "AdjEuler",
	AdjNavierStokes:            "AdjNavierStokes",
	AdjRans:                    "AdjRans",
	AdjTne2Euler:               "AdjTne2Euler",
	AdjTne2NavierStokes:        "AdjTne2NavierStokes",
	Euler:                      "Euler",
	FluidStructureEuler:        "FluidStructureEuler",
	FluidStructureNavierStokes: "FluidStructureNavierStokes",
	FluidStructureRans:         "FluidStructureRans",
	HeatEquation:               "HeatEquation",
	LinEuler:                   "LinEuler",
	LinNavierStokes:            "LinNavierStokes",
	LinearElasticity:           "LinearElasticity",
	NavierStokes:               "NavierStokes",
	NoSolver:                   "NoSolver",
	PoissonEquation:            "PoissonEquation",
	Rans:                       "Rans",
	TemplateSolver:             "TemplateSolver",
	Tne2Euler:                  "Tne2Euler",
	Tne2NavierStokes:           "Tne2NavierStokes",
	WaveEquation:               "WaveEquation",
}

var mapSolverToConfig = map[Solver]string{
	AdjEuler:                   "ADJ_EULER",
	AdjNavierStokes:            "ADJ_NAVIER_STOKES",
	AdjRans:                    "ADJ_RANS",
	AdjTne2Euler:               "ADJ_TNE2_EULER",
	AdjTne2NavierStokes:        "ADJ_TNE2_NAVIER_STOKES",
	Euler:                      "EULER",
	FluidStructureEuler:        "FLUID_STRUCTURE_EULER",
	FluidStructureNavierStokes: "FLUID_STRUCTURE_NAVIER_STOKES",
	FluidStructureRans:         "FLUID_STRUCTURE_RANS",
	HeatEquation:               "HEAT_EQUATION",
	LinEuler:                   "LIN_EULER",
	LinNavierStokes:            "LIN_NAVIER_STOKES",
	LinearElasticity:           "LINEAR_ELASTICITY",
	NavierStokes:               "NAVIER_STOKES",
	NoSolver:                   "NONE",
	PoissonEquation:            "POISSON_EQUATION",
	Rans:                       "RANS",
	TemplateSolver:             "TEMPLATE_SOLVER",
	Tne2Euler:                  "TNE2_EULER",
	Tne2NavierStokes:           "TNE2_NAVIER_STOKES",
	WaveEquation:               "WAVE_EQUATION",
}

var mapSolverFromConfig = map[string]Solver{
	"ADJ_EULER":                     AdjEuler,
	"ADJ_NAVIER_STOKES":             AdjNavierStokes,
	"ADJ_RANS":                      AdjRans,
	"ADJ_TNE2_EULER":                AdjTne2Euler,
	"ADJ_TNE2_NAVIER_STOKES":        AdjTne2NavierStokes,
	"EULER":                         Euler,
	"FLUID_STRUCTURE_EULER":         FluidStructureEuler,
	"FLUID_STRUCTURE_NAVIER_STOKES": FluidStructureNavierStokes,
	"FLUID_STRUCTURE_RANS":          FluidStructureRans,
	"HEAT_EQUATION":                 HeatEquation,
	"LIN_EULER":                     LinEuler,
	"LIN_NAVIER_STOKES":             LinNavierStokes,
	"LINEAR_ELASTICITY":             LinearElasticity,
	"NAVIER_STOKES":                 NavierStokes,
	"NONE":                          NoSolver,
	"POISSON_EQUATION":              PoissonEquation,
	"RANS":                          Rans,
	"TEMPLATE_SOLVER":               TemplateSolver,
	"TNE2_EULER":                    Tne2Euler,
	"TNE2_NAVIER_STOKES":            Tne2NavierStokes,
	"WAVE_EQUATION":                 WaveEquation,
}

type Source uint16

func (e Source) String() string {
	return mapSource[e]
}

func (e Source) ConfigString() string {
	return mapSourceToConfig[e]
}

func (e *Source) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Source")
	}
	enum, ok := mapSourceFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	ChargeDist Source = iota
	NoSource
	PiecewiseConstant
	SourceTemplate
)

var mapSource = map[Source]string{
	ChargeDist:        "ChargeDist",
	NoSource:          "NoSource",
	PiecewiseConstant: "PiecewiseConstant",
	SourceTemplate:    "SourceTemplate",
}

var mapSourceToConfig = map[Source]string{
	ChargeDist:        "CHARGE_DIST",
	NoSource:          "NONE",
	PiecewiseConstant: "PIECEWISE_CONSTANT",
	SourceTemplate:    "TEMPLATE_SOURCE_METHOD",
}

var mapSourceFromConfig = map[string]Source{
	"CHARGE_DIST":            ChargeDist,
	"NONE":                   NoSource,
	"PIECEWISE_CONSTANT":     PiecewiseConstant,
	"TEMPLATE_SOURCE_METHOD": SourceTemplate,
}

type Sourcejac uint16

func (e Sourcejac) String() string {
	return mapSourcejac[e]
}

func (e Sourcejac) ConfigString() string {
	return mapSourcejacToConfig[e]
}

func (e *Sourcejac) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Sourcejac")
	}
	enum, ok := mapSourcejacFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	AutoDiff Sourcejac = iota
	FiniteDiff
	NoJacobian
)

var mapSourcejac = map[Sourcejac]string{
	AutoDiff:   "AutoDiff",
	FiniteDiff: "FiniteDiff",
	NoJacobian: "NoJacobian",
}

var mapSourcejacToConfig = map[Sourcejac]string{
	AutoDiff:   "AUTO_DIFF",
	FiniteDiff: "FINITE_DIFF",
	NoJacobian: "NO_JACOBIAN",
}

var mapSourcejacFromConfig = map[string]Sourcejac{
	"AUTO_DIFF":   AutoDiff,
	"FINITE_DIFF": FiniteDiff,
	"NO_JACOBIAN": NoJacobian,
}

type Space uint16

func (e Space) String() string {
	return mapSpace[e]
}

func (e Space) ConfigString() string {
	return mapSpaceToConfig[e]
}

func (e *Space) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Space")
	}
	enum, ok := mapSpaceFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	NoConvective Space = iota
	SpaceCentered
	SpaceUpwind
)

var mapSpace = map[Space]string{
	NoConvective:  "NoConvective",
	SpaceCentered: "SpaceCentered",
	SpaceUpwind:   "SpaceUpwind",
}

var mapSpaceToConfig = map[Space]string{
	NoConvective:  "NONE",
	SpaceCentered: "SPACE_CENTERED",
	SpaceUpwind:   "SPACE_UPWIND",
}

var mapSpaceFromConfig = map[string]Space{
	"NONE":           NoConvective,
	"SPACE_CENTERED": SpaceCentered,
	"SPACE_UPWIND":   SpaceUpwind,
}

type SpatialOrder uint16

func (e SpatialOrder) String() string {
	return mapSpatialOrder[e]
}

func (e SpatialOrder) ConfigString() string {
	return mapSpatialOrderToConfig[e]
}

func (e *SpatialOrder) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field SpatialOrder")
	}
	enum, ok := mapSpatialOrderFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	FirstOrder SpatialOrder = iota
	SecondOrder
	SecondOrderLimiter
)

var mapSpatialOrder = map[SpatialOrder]string{
	FirstOrder:         "FirstOrder",
	SecondOrder:        "SecondOrder",
	SecondOrderLimiter: "SecondOrderLimiter",
}

var mapSpatialOrderToConfig = map[SpatialOrder]string{
	FirstOrder:         "1ST_ORDER",
	SecondOrder:        "2ND_ORDER",
	SecondOrderLimiter: "2ND_ORDER_LIMITER",
}

var mapSpatialOrderFromConfig = map[string]SpatialOrder{
	"1ST_ORDER":         FirstOrder,
	"2ND_ORDER":         SecondOrder,
	"2ND_ORDER_LIMITER": SecondOrderLimiter,
}

type TimeInt uint16

func (e TimeInt) String() string {
	return mapTimeInt[e]
}

func (e TimeInt) ConfigString() string {
	return mapTimeIntToConfig[e]
}

func (e *TimeInt) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field TimeInt")
	}
	enum, ok := mapTimeIntFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	EulerExplicit TimeInt = iota
	EulerImplicit
	RungeKuttaExplicit
)

var mapTimeInt = map[TimeInt]string{
	EulerExplicit:      "EulerExplicit",
	EulerImplicit:      "EulerImplicit",
	RungeKuttaExplicit: "RungeKuttaExplicit",
}

var mapTimeIntToConfig = map[TimeInt]string{
	EulerExplicit:      "EULER_EXPLICIT",
	EulerImplicit:      "EULER_IMPLICIT",
	RungeKuttaExplicit: "RUNGE-KUTTA_EXPLICIT",
}

var mapTimeIntFromConfig = map[string]TimeInt{
	"EULER_EXPLICIT":       EulerExplicit,
	"EULER_IMPLICIT":       EulerImplicit,
	"RUNGE-KUTTA_EXPLICIT": RungeKuttaExplicit,
}

type TransModel uint16

func (e TransModel) String() string {
	return mapTransModel[e]
}

func (e TransModel) ConfigString() string {
	return mapTransModelToConfig[e]
}

func (e *TransModel) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field TransModel")
	}
	enum, ok := mapTransModelFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Lm TransModel = iota
	NoTransModel
)

var mapTransModel = map[TransModel]string{
	Lm:           "Lm",
	NoTransModel: "NoTransModel",
}

var mapTransModelToConfig = map[TransModel]string{
	Lm:           "LM",
	NoTransModel: "NONE",
}

var mapTransModelFromConfig = map[string]TransModel{
	"LM":   Lm,
	"NONE": NoTransModel,
}

type TurbModel uint16

func (e TurbModel) String() string {
	return mapTurbModel[e]
}

func (e TurbModel) ConfigString() string {
	return mapTurbModelToConfig[e]
}

func (e *TurbModel) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field TurbModel")
	}
	enum, ok := mapTurbModelFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Ml TurbModel = iota
	NoTurbModel
	Sa
	Sst
)

var mapTurbModel = map[TurbModel]string{
	Ml:          "Ml",
	NoTurbModel: "NoTurbModel",
	Sa:          "Sa",
	Sst:         "Sst",
}

var mapTurbModelToConfig = map[TurbModel]string{
	Ml:          "ML",
	NoTurbModel: "NONE",
	Sa:          "SA",
	Sst:         "SST",
}

var mapTurbModelFromConfig = map[string]TurbModel{
	"ML":   Ml,
	"NONE": NoTurbModel,
	"SA":   Sa,
	"SST":  Sst,
}

type Unsteady uint16

func (e Unsteady) String() string {
	return mapUnsteady[e]
}

func (e Unsteady) ConfigString() string {
	return mapUnsteadyToConfig[e]
}

func (e *Unsteady) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Unsteady")
	}
	enum, ok := mapUnsteadyFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	DtStepping1st Unsteady = iota
	DtStepping2nd
	RotationalFrame
	Steady
	TimeSpectral
	TimeStepping
)

var mapUnsteady = map[Unsteady]string{
	DtStepping1st:   "DtStepping1st",
	DtStepping2nd:   "DtStepping2nd",
	RotationalFrame: "RotationalFrame",
	Steady:          "Steady",
	TimeSpectral:    "TimeSpectral",
	TimeStepping:    "TimeStepping",
}

var mapUnsteadyToConfig = map[Unsteady]string{
	DtStepping1st:   "DUAL_TIME_STEPPING-1ST_ORDER",
	DtStepping2nd:   "DUAL_TIME_STEPPING-2ND_ORDER",
	RotationalFrame: "ROTATIONAL_FRAME",
	Steady:          "NO",
	TimeSpectral:    "TIME_SPECTRAL",
	TimeStepping:    "TIME_STEPPING",
}

var mapUnsteadyFromConfig = map[string]Unsteady{
	"DUAL_TIME_STEPPING-1ST_ORDER": DtStepping1st,
	"DUAL_TIME_STEPPING-2ND_ORDER": DtStepping2nd,
	"ROTATIONAL_FRAME":             RotationalFrame,
	"NO":                           Steady,
	"TIME_SPECTRAL":                TimeSpectral,
	"TIME_STEPPING":                TimeStepping,
}

type Upwind uint16

func (e Upwind) String() string {
	return mapUpwind[e]
}

func (e Upwind) ConfigString() string {
	return mapUpwindToConfig[e]
}

func (e *Upwind) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Upwind")
	}
	enum, ok := mapUpwindFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	Ausm Upwind = iota
	Ausmpwplus
	ConvectiveTemplate
	Cusp
	Hllc
	Msw
	NoUpwind
	Roe
	ScalarUpwind
	Sw
	Turkel
)

var mapUpwind = map[Upwind]string{
	Ausm:               "Ausm",
	Ausmpwplus:         "Ausmpwplus",
	ConvectiveTemplate: "ConvectiveTemplate",
	Cusp:               "Cusp",
	Hllc:               "Hllc",
	Msw:                "Msw",
	NoUpwind:           "NoUpwind",
	Roe:                "Roe",
	ScalarUpwind:       "ScalarUpwind",
	Sw:                 "Sw",
	Turkel:             "Turkel",
}

var mapUpwindToConfig = map[Upwind]string{
	Ausm:               "AUSM",
	Ausmpwplus:         "AUSMPW+",
	ConvectiveTemplate: "CONVECTIVE_TEMPLATE",
	Cusp:               "CUSP",
	Hllc:               "HLLC",
	Msw:                "MSW",
	NoUpwind:           "NONE",
	Roe:                "ROE",
	ScalarUpwind:       "SCALAR_UPWIND",
	Sw:                 "SW",
	Turkel:             "TURKEL_PREC",
}

var mapUpwindFromConfig = map[string]Upwind{
	"AUSM":                Ausm,
	"AUSMPW+":             Ausmpwplus,
	"CONVECTIVE_TEMPLATE": ConvectiveTemplate,
	"CUSP":                Cusp,
	"HLLC":                Hllc,
	"MSW":                 Msw,
	"NONE":                NoUpwind,
	"ROE":                 Roe,
	"SCALAR_UPWIND":       ScalarUpwind,
	"SW":                  Sw,
	"TURKEL_PREC":         Turkel,
}

type Viscous uint16

func (e Viscous) String() string {
	return mapViscous[e]
}

func (e Viscous) ConfigString() string {
	return mapViscousToConfig[e]
}

func (e *Viscous) FromConfigString(str []string) error {
	if len(str) != 1 {
		return errors.New("multiple values for field Viscous")
	}
	enum, ok := mapViscousFromConfig[str[0]]
	if !ok {
		return Unknown
	}
	*e = enum
	return nil
}

const (
	AvgGrad Viscous = iota
	AvgGradCorrected
	Galerkin
	NoViscous
)

var mapViscous = map[Viscous]string{
	AvgGrad:          "AvgGrad",
	AvgGradCorrected: "AvgGradCorrected",
	Galerkin:         "Galerkin",
	NoViscous:        "NoViscous",
}

var mapViscousToConfig = map[Viscous]string{
	AvgGrad:          "AVG_GRAD",
	AvgGradCorrected: "AVG_GRAD_CORRECTED",
	Galerkin:         "GALERKIN",
	NoViscous:        "NONE",
}

var mapViscousFromConfig = map[string]Viscous{
	"AVG_GRAD":           AvgGrad,
	"AVG_GRAD_CORRECTED": AvgGradCorrected,
	"GALERKIN":           Galerkin,
	"NONE":               NoViscous,
}
