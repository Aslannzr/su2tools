package main

import (
	"bufio"
	"encoding/json"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"go/format"
	autogen "github.com/btracey/su2tools/config/enum/autogen/autogencommon"
)

var su2home string
var gopath string
var savepath string // where to save the finished JSON files
var enumpath string // where to write the autogenerated files
var enumJsonFilename string

func init() {
	// Get gopath and su2home
	gopath = os.Getenv("GOPATH")
	if gopath == "" {
		log.Fatal("GOPATH must be set")
	}
	su2home = os.Getenv("SU2_HOME")
	if su2home == "" {
		log.Fatal("SU2_HOME must be set")
	}
	enumpath = filepath.Join(gopath, "src", "github.com", "btracey", "su2tools", "config", "enum")
	savepath = filepath.Join(enumpath, "autogen")
	enumJsonFilename = filepath.Join(savepath, "enum_options.json")
}

func main() {
	readEnumsFromSource()
	writeEnumFiles()
}

func readEnumsFromSource() {
	optionFilename := filepath.Join(su2home, "Common", "include", "option_structure.hpp")
	optionFile, err := os.Open(optionFilename)
	if err != nil {
		log.Fatal("error opening option: " + err.Error())
	}
	defer optionFile.Close()

	// Find all of the enum options and their maps
	enums := make(map[string]*autogen.EnumType) // list of all of the enum types

	scanner := bufio.NewScanner(optionFile)

	for scanner.Scan() {
		line := scanner.Text()
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "enum ") {
			parseEnum(scanner, enums, line)
		}
		if strings.HasPrefix(line, "static const map<string,") {
			parseMap(scanner, enums, line)
		}
	}
	if scanner.Err() != nil {
		log.Fatalf("error scanning option_structure.hpp: ", scanner.Err())
	}

	// Do some error checking
	for _, enum := range enums {
		if enum.Mapname == "" {
			// No enum map, not for config
			continue
		}
		var noString bool
		var hasString bool
		for _, option := range enum.Option {
			if option.ConfigString == "" {
				noString = true
			}
			hasString = true
		}
		if noString && hasString {
			log.Fatalf("For enum type %s, only some values have strings", enum.Typename)
		}
	}

	// Print all of the enums as a JSON file
	enumJson, err := os.Create(enumJsonFilename)
	if err != nil {
		log.Fatal(err.Error())
	}
	defer enumJson.Close()

	b, err := json.MarshalIndent(enums, "", "\t")
	if err != nil {
		log.Fatalf("error marshaling: %s", err)
	}
	enumJson.Write(b)
}

func parseEnum(scanner *bufio.Scanner, enums map[string]*autogen.EnumType, line string) {
	strs := strings.Split(line, " ")
	if len(strs) != 3 {
		log.Fatal("option line with a split not equal to 3: ", line)
	}
	if strs[2] != "{" {
		log.Fatal("Enum line doesn't end with { :", line)
	}
	enumType := strs[1]
	enumType = autogen.FixEnumType(enumType)
	enum := &autogen.EnumType{
		Typename: enumType,
		Option:   make(map[string]*autogen.EnumOption),
	}

	// Scan to find all of the values
	for scanner.Scan() {
		line = scanner.Text()
		line = strings.TrimSpace(line)
		if len(line) == 0 {
			continue
		}
		if line[0] == '}' { // Found the end of the enum options
			break
		}
		strs = strings.Split(line, "=")
		if len(strs) == 1 {
			log.Fatalf("enum line has no equals sign: %s", line)
		}
		id := strings.TrimSpace(strs[0])
		id = autogen.FixEnumId(id)
		enum.Option[id] = &autogen.EnumOption{Identifier: id}
	}
	if scanner.Err() != nil {
		log.Fatalf("error scanning: ", scanner.Err())
	}
	_, ok := enums[enumType]
	if ok {
		log.Fatalf("Duplicate enum type %s", enumType)
	}

	enums[enumType] = enum
}

func parseMap(scanner *bufio.Scanner, enums map[string]*autogen.EnumType, line string) {
	line = strings.TrimPrefix(line, "static const map<string,")
	strs := strings.Split(line, ">")
	if len(strs) <= 2 {
		log.Fatalf("bad map parsing of line: %s", line)
	}
	typename := strs[0]
	typename = autogen.FixEnumType(typename)

	enum, ok := enums[typename]
	if !ok {
		log.Fatalf("typename %s not found in enums map", typename)
	}

	strs2 := strings.Split(strs[1], "=")

	mapname := autogen.FixMapname(strs2[0])

	enum.Mapname = mapname

	for scanner.Scan() {
		line = scanner.Text()
		line = strings.TrimSpace(line)
		if len(line) == 0 {
			continue
		}
		if !(line[0] == '(') {
			log.Fatalf("error parsing map entry: %s ", line)
		}
		line = strings.TrimPrefix(line, "(")
		strs = strings.Split(line, ",")

		if len(strs) < 2 {
			log.Fatalf("error parsing map entry: %s", line)
		}
		// First entry is the string name
		stringId := strings.TrimSpace(strs[0])

		if stringId[0] != '"' {
			log.Fatal("map string does not start with \"")
		}
		if stringId[len(stringId)-1] != '"' {
			log.Fatal("map string does not end with \"")
		}
		stringId = stringId[1 : len(stringId)-1]

		enumStr := strings.TrimSpace(strs[1])

		var containsSemicolon bool
		if strings.Contains(enumStr, ";") {
			containsSemicolon = true
		}

		enumStrs := strings.Split(enumStr, ")")
		enumId := autogen.FixEnumId(enumStrs[0])

		option, ok := enum.Option[enumId]
		if !ok {
			log.Fatalf("invalid enum option for map: %v", enumId)
		}
		option.ConfigString = stringId

		if containsSemicolon {
			break
		}
	}
	if scanner.Err() != nil {
		log.Fatalf("error scanning: %v", scanner.Err())
	}
}

func writeEnumFiles() {
	enumFilename := filepath.Join(enumpath, "enum.go")
	enumFile, err := os.Create(enumFilename)
	if err != nil {
		log.Fatal(err.Error())
	}

	header :=
		`// package enum contains a type-safe version of all of the enum types 
// that are accessible from the SU2 config file.

package enum
// This file is autogenerated by github.com/btracey/su2tools/config/enum/autogen/genenum

import "errors"

var Unknown = errors.New("unknown enum string")
`

	enumFile.Write([]byte(header))

	enumJsonFile, err := os.Open(enumJsonFilename)
	if err != nil {
		log.Fatal(err.Error())
	}
	decoder := json.NewDecoder(enumJsonFile)
	var enums map[string]*autogen.EnumType
	decoder.Decode(&enums)

	allEnums := make(enumTypeSlice, 0)
	for _, enum := range enums {
		allEnums = append(allEnums, enum)
	}
	sort.Sort(allEnums)

	autogenEnumFilename := filepath.Join(savepath, "autogenmap.go")

	autogenHeader :=
		`// This file is autogenerated by github.com/btracey/su2tools/config/enum/autogen/genenum
// and is used to help parse the config options
package autogen


`
	autogenFile, err := os.Create(autogenEnumFilename)
	if err != nil {
		log.Fatal(err)
	}

	/*
		unmarshal := `// Unmarshal returns an interface{} given the underlying type and
		   	// su2 string value
		   	func Unmarshal(v interface{}, su2string string) (interface{}, error){
				switch t := v.(type){
				default:
					return nil, errors.New("unknown type")
		   `
	*/

	autogenFile.WriteString(string(autogenHeader))
	autogenFile.WriteString("var MapnameToTypename = map[string]string{\n")

	for _, enum := range allEnums {
		if enum.Mapname == "" {
			continue
		}
		autogenFile.WriteString("\"" + enum.Mapname + "\"" + ": " + "\"" + enum.Typename + "\"" + ",\n")

		es := make(enumSlice, 0)
		for _, opt := range enum.Option {
			es = append(es, opt)
		}
		sort.Sort(es)

		// Print the enum type declaration
		str := "type " + enum.Typename + " uint16" + "\n\n"
		enumFile.WriteString(str)
		str = "func (e " + enum.Typename + ") String() string {\n"
		str += " return map" + enum.Typename + "[e]\n"
		str += "}\n\n"
		enumFile.WriteString(str)

		str = "func (e " + enum.Typename + ") ConfigString() string {\n"
		str += " return map" + enum.Typename + "ToConfig" + "[e]\n"
		str += "}\n\n"
		enumFile.WriteString(str)

		str = "func (e *" + enum.Typename + ") FromConfigString(str []string) error {\n"
		str += "if len(str) != 1{return errors.New(\"multiple values for field " + enum.Typename + "\")}\n"
		str += "enum, ok := map" + enum.Typename + "FromConfig[str[0]]\n"
		str += "if !ok{\n"
		str += "return Unknown\n"
		str += "}\n"
		str += "*e = enum\n"
		str += "return nil\n"
		str += "}\n\n"
		enumFile.WriteString(str)

		str = "const(\n"
		enumFile.WriteString(str)

		for i, opt := range es {
			str = opt.Identifier
			if i == 0 {
				str += " " + enum.Typename + " = iota"
			}
			str += "\n"
			enumFile.WriteString(str)
		}
		enumFile.WriteString(")\n\n")

		strTo := "var map" + enum.Typename + "ToConfig = map[" + enum.Typename + "] string {\n"
		strFrom := "var map" + enum.Typename + "FromConfig = map[string]" + enum.Typename + " {\n"
		strString := "var map" + enum.Typename + " = map[" + enum.Typename + "] string {\n"
		for _, opt := range es {
			strTo += opt.Identifier + ": \"" + opt.ConfigString + "\",\n"
			strFrom += "\"" + opt.ConfigString + "\": " + opt.Identifier + ",\n"
			strString += opt.Identifier + ": \"" + opt.Identifier + "\",\n"
		}
		/*
			unmarshal += "case " + enum.Typename + ":\n"
			unmarshal += "val, ok := map" + enum.Typename + "FromConfig[t]\n"
			unmarshal += "if !ok{return nil, fmt.Errorf(\"unknown value: %s\", t)}\n"
			unmarshal += "return val, nil\n"
		*/

		strTo += "}\n\n"
		strFrom += "}\n\n"
		strString += "}\n\n"
		enumFile.WriteString(strString)
		enumFile.WriteString(strTo)
		enumFile.WriteString(strFrom)
	}
	//unmarshal += "}\n"
	autogenFile.WriteString("}\n")
	//enumFile.WriteString(mapAll)

	enumFile.Close()
	autogenFile.Close()

	b, err := ioutil.ReadFile(enumFilename)
	if err != nil {
		log.Fatal("error reloading enum " + err.Error())
	}
	b, err = format.Source(b)
	if err != nil {
		log.Fatal("error formatting enum " + err.Error())
	}
	err = ioutil.WriteFile(enumFilename, b, 0700)
	if err != nil {
		log.Fatal("error writing formatted enum " + err.Error())
	}

	b, err = ioutil.ReadFile(autogenEnumFilename)
	if err != nil {
		log.Fatal("error reloading autogen " + err.Error())
	}
	b, err = format.Source(b)
	if err != nil {
		log.Fatal("error formatting autogen " + err.Error())
	}
	err = ioutil.WriteFile(autogenEnumFilename, b, 0700)
	if err != nil {
		log.Fatal("error writing formatted autogen " + err.Error())
	}
}

type enumSlice []*autogen.EnumOption

func (e enumSlice) Len() int {
	return len(e)
}

func (e enumSlice) Swap(i, j int) {
	e[i], e[j] = e[j], e[i]
}

func (e enumSlice) Less(i, j int) bool {
	return e[i].Identifier < e[j].Identifier
}

type enumTypeSlice []*autogen.EnumType

func (e enumTypeSlice) Len() int {
	return len(e)
}

func (e enumTypeSlice) Swap(i, j int) {
	e[i], e[j] = e[j], e[i]
}

func (e enumTypeSlice) Less(i, j int) bool {
	return e[i].Typename < e[j].Typename
}
